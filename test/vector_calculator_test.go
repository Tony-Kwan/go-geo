package test

import (
	"fmt"
	"github.com/Tony-Kwan/go-geo/geo"
	"github.com/Tony-Kwan/go-geo/geo/io/wkt"
	"github.com/atotto/clipboard"
	"math"
	"testing"
)

func Benchmark_MinCoverCircle(b *testing.B) {
	//wktStr := "POLYGON((120.584017 30.334264,120.616301 30.273781,120.526286 30.244407,120.501884 30.284578,120.584017 30.334264,120.345366 30.212234,120.368149 30.177084,120.284766 30.127091,120.248699 30.187233,120.345366 30.212234,120.52629261821812 30.24436668295212,120.52697582270933 30.233299334035987,120.52382297492878 30.216926182050383,120.50816882313957 30.192957338856885,120.483794 30.177527,120.43219775825095 30.16072212797702,120.40038343656032 30.16166599384457,120.37713335485847 30.17080612177303,120.368149 30.177084,120.34537517739905 30.212194490559547,120.34438558172529 30.217674992600042,120.34778835792177 30.24504085732033,120.36426475505374 30.26859901749025,120.382862 30.280802,120.416186504205 30.295798257235646,120.44058500229838 30.30241947134751,120.4661354368617 30.301431620999843,120.49500712737346 30.289765916116554,120.501884 30.284578,120.52629261821812 30.24436668295212,120.5953138486885 30.39368525224143,120.68281747356784 30.230453059776597,120.27156347260748 30.06603842681942,120.1842060444106 30.229270619443145,120.5953138486885 30.39368525224143,120.574023 30.350935,120.606332 30.287108,120.514625 30.261084,120.491845 30.30125,120.574023 30.350935,120.335386 30.230601,120.358116 30.190422,120.274747 30.140427,120.242044 30.200586,120.335386 30.230601,120.51463306543144 30.26104406230654,120.51572370882518 30.250001097220096,120.51317486382023 30.23354956586078,120.50876208686653 30.223142956821338,120.49840831046319 30.209162540888467,120.477138 30.194198,120.42572487592481 30.17352591501829,120.39388785681989 30.17355089354241,120.36504062974964 30.185198748272395,120.358116 30.190422,120.33539312139733 30.23056081396441,120.33498290762775 30.247155269232408,120.33749194435569 30.258024365139146,120.35283562834141 30.28214751503115,120.376206 30.297473,120.42752707781861 30.314916441792395,120.45307374576718 30.316036178574258,120.48310678971662 30.30680009209954,120.491845 30.30125,120.51463306543144 30.26104406230654,120.58865815180187 30.408691824196655,120.67618595808533 30.24546393634518,120.26488532399638 30.0810311963203,120.17750385884608 30.244259084330878,120.58865815180187 30.408691824196655))"
	wktStr := "POLYGON((36.8712349241 -17.81995830529999,36.8738038628152 -17.845126076571063,36.9019640036 -17.84241837179998,36.9031032226 -17.853155611599988,36.874900260758736 -17.85586743544495,36.8783840811 -17.889998258800006,36.8670969767 -17.891041469699985,36.863619552469274 -17.8569521191707,36.8380354527 -17.85941212930001,36.8368956706 -17.84867493979999,36.86252382934768 -17.846210694743675,36.8599522733 -17.8210016119,36.8712349241 -17.81995830529999,36.8730055428 -17.787266598000002,36.8712349241 -17.81995830529999,36.8599522733 -17.8210016119,36.8516074627 -17.789245275,36.8730055428 -17.787266598000002,36.8783840811 -17.889998258800006,36.8867348133 -17.92175431160001,36.8653246925 -17.9237331459,36.8670969767 -17.891041469699985,36.8783840811 -17.889998258800006,36.8025446374 -17.847112557200006,36.8368956706 -17.84867493979999,36.8380354527 -17.85941212930001,36.8047026124 -17.867478022599983,36.8025446374 -17.847112557200006,36.9019640036 -17.84241837179998,36.9352910304 -17.83434829230002,36.9374556474 -17.854713500900004,36.9031032226 -17.853155611599988,36.9019640036 -17.84241837179998,36.8771344688 -17.7109858859,36.8730055428 -17.787266598000002,36.8516074627 -17.789245275,36.8321477666 -17.715145782500002,36.8771344688 -17.7109858859,36.8867348133 -17.92175431160001,36.906231511 -17.995850380500002,36.8611868155 -18.000013661300002,36.8653246925 -17.9237331459,36.8867348133 -17.92175431160001,36.7223945806 -17.843443634400003,36.8025446374 -17.847112557200006,36.8047026124 -17.867478022599983,36.726914224 -17.886276410799994,36.7223945806 -17.843443634400003,36.9352910304 -17.83434829230002,37.0130423426 -17.815496135299995,37.0176136372 -17.858325199099994,36.9374556474 -17.854713500900004,36.9352910304 -17.83434829230002))"
	var polygon = wkt.MustPolygon(wkt.WktReader{}.Read(wktStr))
	for i := 0; i < b.N; i++ {
		circle, err := calc.MinCoverCircle(polygon.Shell...)
		if err != nil {
			b.Error(err)
			return
		}
		fmt.Println(circle.GetRadius() * geo.EarthRadius)
	}
}

func Test_MinCoverCircle(t *testing.T) {
	//wktStr := "POLYGON((120.584017 30.334264,120.616301 30.273781,120.526286 30.244407,120.501884 30.284578,120.584017 30.334264,120.345366 30.212234,120.368149 30.177084,120.284766 30.127091,120.248699 30.187233,120.345366 30.212234,120.52629261821812 30.24436668295212,120.52697582270933 30.233299334035987,120.52382297492878 30.216926182050383,120.50816882313957 30.192957338856885,120.483794 30.177527,120.43219775825095 30.16072212797702,120.40038343656032 30.16166599384457,120.37713335485847 30.17080612177303,120.368149 30.177084,120.34537517739905 30.212194490559547,120.34438558172529 30.217674992600042,120.34778835792177 30.24504085732033,120.36426475505374 30.26859901749025,120.382862 30.280802,120.416186504205 30.295798257235646,120.44058500229838 30.30241947134751,120.4661354368617 30.301431620999843,120.49500712737346 30.289765916116554,120.501884 30.284578,120.52629261821812 30.24436668295212,120.5953138486885 30.39368525224143,120.68281747356784 30.230453059776597,120.27156347260748 30.06603842681942,120.1842060444106 30.229270619443145,120.5953138486885 30.39368525224143,120.574023 30.350935,120.606332 30.287108,120.514625 30.261084,120.491845 30.30125,120.574023 30.350935,120.335386 30.230601,120.358116 30.190422,120.274747 30.140427,120.242044 30.200586,120.335386 30.230601,120.51463306543144 30.26104406230654,120.51572370882518 30.250001097220096,120.51317486382023 30.23354956586078,120.50876208686653 30.223142956821338,120.49840831046319 30.209162540888467,120.477138 30.194198,120.42572487592481 30.17352591501829,120.39388785681989 30.17355089354241,120.36504062974964 30.185198748272395,120.358116 30.190422,120.33539312139733 30.23056081396441,120.33498290762775 30.247155269232408,120.33749194435569 30.258024365139146,120.35283562834141 30.28214751503115,120.376206 30.297473,120.42752707781861 30.314916441792395,120.45307374576718 30.316036178574258,120.48310678971662 30.30680009209954,120.491845 30.30125,120.51463306543144 30.26104406230654,120.58865815180187 30.408691824196655,120.67618595808533 30.24546393634518,120.26488532399638 30.0810311963203,120.17750385884608 30.244259084330878,120.58865815180187 30.408691824196655))"
	wktStr := "POLYGON((-59.6041254198 -4.35214380483,-59.5821896302 -4.35479960359,-59.5622941077 -4.36528286931,-59.5483942862 -4.38292831466,-59.544497316 -4.39351857585,-59.5428937511 -4.40468525889,-59.5436537759 -4.41594034128,-59.5467442785 -4.42679191529,-59.5592808153 -4.44542571334,-59.5783359824 -4.45736433927,-59.5893077219 -4.46012107079,-59.6225511747 -4.4578871735,-59.6424485272 -4.44740268525,-59.6563476611 -4.42975575782,-59.6602434318 -4.41916498846,-59.6618454803 -4.4079980846,-59.661083891 -4.39674310788,-59.6579920534 -4.38589194732,-59.6454544051 -4.36725956413,-59.626400699 -4.35532228378,-59.6041254198 -4.35214380483))"
	//wktStr := "POLYGON((27.441299426229907 -20.495564086033284,27.477359919468622 -22.341258684200255,29.910477307013096 -21.24774650622193,28.91182242283068 -20.531922648194026,27.441299426229907 -20.495564086033284))"
	//wktStr := "POLYGON((18.1477239541851 -32.9072693112793,18.174563389 -32.9053001332,18.1998035342 -32.912677656,18.2192936873 -32.9280326254,18.2257733637 -32.9379156658,18.2296643235 -32.948713292,18.2326237484 -32.9831005915,18.2250166569 -33.0046118642,18.2076292559 -33.0216665633,18.1834667615 -33.0313125342,18.1580032634 -33.0328742806,18.1411637763 -33.0302183277,18.1182026391 -33.0186934394,18.1016850346 -33.0012665247,18.089939344 -32.9811075075,18.0880583496 -32.9699378564,18.0889866599 -32.9586842136,18.0973810167 -32.9399939276,18.1147859729 -32.9229633955,18.12975271 -32.9129122926,18.1477239541851 -32.9072693112793))"
	var polygon = wkt.MustPolygon(wkt.WktReader{}.Read(wktStr))
	circle, err := calc.MinCoverCircle(polygon.Shell...)
	if err != nil {
		t.Error(err)
		return
	}
	t.Log(circle.GetRadius() * geo.EarthRadius)
	cirPolygon := circle.ToPolygon(32)
	wkt := fmt.Sprintf("GEOMETRYCOLLECTION(%s,%s)", polygon.String(), cirPolygon.String())
	t.Log(wkt)
	clipboard.WriteAll(wkt)
}

func Test_Circumcenter(t *testing.T) {
	wktStr := "POLYGON((38.76555701717734 -5.175279739072806,38.76362356357276 -5.18002816254014,38.76945284195244 -5.180763842347915,38.76555701717734 -5.175279739072806))"
	//wktStr := "POLYGON((38.76555701717734 5.175279739072806,38.76362356357276 5.18002816254014,38.76945284195244 5.180763842347915,38.76555701717734 5.175279739072806))"
	polygon := wkt.MustPolygon(wkt.WktReader{}.Read(wktStr))
	p1, p2, p3 := polygon.Shell[0], polygon.Shell[1], polygon.Shell[2]
	calc := geo.VectorCalculator{}
	c, err := calc.Circumcenter(p1, p2, p3)
	if err != nil {
		t.Error(err)
		return
	}
	t.Log(c)
	d1, d2, d3 := calc.Distance(c, p1), calc.Distance(c, p2), calc.Distance(c, p3)
	maxd := math.Max(d1, math.Max(d2, d3))
	t.Log(d1, d2, d3, maxd)
	circle := geo.NewCircle(c.X(), c.Y(), maxd, geo.GeoCtx)
	cp := circle.ToPolygon(64)
	clipboard.WriteAll(fmt.Sprintf("GEOMETRYCOLLECTION(%s,%s)", polygon.String(), cp.String()))
}

//func TestVectorCalculator_LngLat2nE(t *testing.T) {
//	fmt.Println(newNE(0, 90))
//}
//
//func TestVectorCalculator_nE2Lnglat(t *testing.T) {
//	ll := newNE(0, 90).toPoint()
//	fmt.Println(ll)
//}
//
//func TestVectorCalculator_meanPosition(t *testing.T) {
//	points := []*Point{
//		NewPoint(-81.9465923309326, 36.309868813086695, nil),
//		NewPoint(-84.01296615600586, 33.51764054105411, nil),
//	}
//	m := vectorCalc.MeanPosition(points...)
//	fmt.Println(m)
//	for _, nE := range points {
//		fmt.Println(vectorCalc.Distance(m, nE) * EarthRadius)
//	}
//}
//
//func TestVectorCalculator_Mid(t *testing.T) {
//	from := NewPoint(-81.9465923309326, 36.309868813086695, nil)
//	to := NewPoint(-84.01296615600586, 33.51764054105411, nil)
//	fmt.Println(vectorCalc.Mid(from, to, GeoCtx))
//	fmt.Println(sphereCalc.Mid(from, to, GeoCtx))
//}
//
//func TestVectorCalculator_PointOnBearing(t *testing.T) {
//	info.Println(p1, "->", p2)
//	dist := vectorCalc.Distance(p1, p2)
//	bearingDeg := vectorCalc.Bearing(p1, p2)
//	p3 := vectorCalc.PointOnBearing(p1, dist, bearingDeg, GeoCtx)
//	info.Println(dist * EarthRadius)
//	info.Println(bearingDeg)
//	info.Println(p3)
//}
//
//func TestVectorCalculator_Distance(t *testing.T) {
//	p1 := NewPoint(-83.85829925537108, 37.351328227794866, nil)
//	p2 := NewPoint(-86.93447113037108, 32.600915527883345, nil)
//	dis1 := vectorCalc.Distance(p1, p2)
//	dis2 := sphereCalc.Distance(p1, p2)
//	fmt.Println(dis1, dis2)
//	fmt.Println(dis1*EarthRadius, dis2*EarthRadius)
//	fmt.Println((dis1 - dis2) * EarthRadius)
//}
//
//func TestVectorCalculator_IntersectionOfTwoPath(t *testing.T) {
//	p1 := NewPoint(113.021085, 23.292487, nil)
//	p2 := NewPoint(113.212321, 23.253895, nil)
//	p3 := NewPoint(113.212321, 23.253895+E10, nil)
//
//	p4, err := vectorCalc.IntersectionOfTwoPath(p1, p2, p1, p3)
//	if err != nil {
//		t.Error(err)
//		return
//	}
//	fmt.Println(p4)
//}
//
//func TestVectorCalculator_Triangulation(t *testing.T) {
//	p1 := NewPoint(113.021085, 23.292487, nil)
//	p2 := NewPoint(113.212321, 23.253895, nil)
//	p3 := NewPoint(113.121248, 22.873807, nil)
//	bearing12 := vectorCalc.Bearing(p1, p2)
//	bearing23 := vectorCalc.Bearing(p2, p3)
//	bearing32 := vectorCalc.Bearing(p3, p2)
//	tests := []struct {
//		points   [2]*Point
//		bearings [2]float64
//		want     *Point
//	}{
//		{
//			points:   [2]*Point{p1, p2},
//			bearings: [2]float64{bearing12, bearing23},
//			want:     p2,
//		},
//		{
//			points:   [2]*Point{p1, p3},
//			bearings: [2]float64{bearing12, bearing32},
//			want:     p2,
//		},
//		{
//			points:   [2]*Point{NewPoint(0, 0, nil), NewPoint(1, 0, nil)},
//			bearings: [2]float64{0, 90},
//			want:     NewPoint(0, 0, nil),
//		},
//	}
//	for _, test := range tests {
//		p4, err := vectorCalc.Triangulation(test.points[0], test.bearings[0], test.points[1], test.bearings[1])
//		if err != nil {
//			t.Error(err)
//			continue
//		} else if !p4.ApproxEqual(test.want) {
//			t.Errorf("expect=%v, found=%v", test.want, p4)
//		}
//	}
//}
//
//func TestVectorCalculator_Circumcenter(t *testing.T) {
//	p1 := NewPoint(113.021085, 23.292487, nil)
//	p2 := NewPoint(113.212321, 23.253895, nil)
//	p3 := NewPoint(113.121248, 22.873807, nil)
//	c, err := vectorCalc.Circumcenter(p1, p2, p3)
//	if err != nil {
//		t.Error(err)
//		return
//	}
//	fmt.Println(c)
//
//	fmt.Println(vectorCalc.Distance(c, p1) * EarthRadius)
//	fmt.Println(vectorCalc.Distance(c, p2) * EarthRadius)
//	fmt.Println(vectorCalc.Distance(c, p3) * EarthRadius)
//}
//
//func TestVectorCalculator_MinCoverCircle(t *testing.T) {
//	points := []*Point{
//		//NewPoint(7.098206748478991, 46.658250853066654, nil),
//		//NewPoint(7.096818204096314, 46.6255295921, nil),
//		//NewPoint(7.081215882059562, 46.62424586456617, nil),
//		//NewPoint(7.068605669086119, 46.655815315282965, nil),
//		//NewPoint(7.098206748478991, 46.658250853066654, nil),
//
//		//NewPoint(7.107510838765815, 46.56415356342374, nil),
//		//NewPoint(7.120093200561858, 46.53258287949015, nil),
//		//NewPoint(7.090541763528792, 46.530148356963075, nil),
//		//NewPoint(7.091926209321755, 46.56286965110933, nil),
//		//NewPoint(7.107510838765815, 46.56415356342374, nil),
//
//		NewPoint(3.4187225890205233, 46.20547150536718, nil),
//		NewPoint(3.4039554760716264, 46.13243249643665, nil),
//		NewPoint(3.3885327467298407, 46.13392817417585, nil),
//		NewPoint(3.403279258370794, 46.20696665022393, nil),
//		NewPoint(3.4187225890205233, 46.20547150536718, nil),
//	}
//	circle, err := vectorCalc.MinCoverCircle(points...)
//	if err != nil {
//		t.Error(err)
//		return
//	}
//	//fmt.Println(circle)
//	fmt.Println(circle.radius * EarthRadius)
//}
//
//func TestVectorCalculator_MinCoverCircle_2(t *testing.T) {
//	for i := 0; i < 1000; i++ {
//		TestVectorCalculator_MinCoverCircle(t)
//	}
//}
//
//func TestVectorCalculator_AreaOfPolygon(t *testing.T) {
//	polygon := &Polygon{shell: LinearRing{
//		*NewPoint(-1.6991043090820295, 43.32317958748908, nil),
//		*NewPoint(3.936882019042976, 42.161367532874806, nil),
//		*NewPoint(3.581542968750002, 43.11953018614551, nil),
//		*NewPoint(6.507682800292972, 42.94360648947236, nil),
//		*NewPoint(7.775917053222664, 43.726700289570346, nil),
//		*NewPoint(7.122917175292971, 44.847836846819575, nil),
//		*NewPoint(6.737022399902351, 46.3104186157758, nil),
//		*NewPoint(7.2142410278320375, 47.52856107277904, nil),
//		*NewPoint(8.028602600097656, 49.073640995014955, nil),
//		*NewPoint(2.7785110473632812, 51.27093716704937, nil),
//		*NewPoint(1.4405822753906263, 50.82654161609699, nil),
//		*NewPoint(1.5284729003906241, 49.996484644867365, nil),
//		*NewPoint(-1.6918945312499958, 49.65629401936761, nil),
//		*NewPoint(-1.718673706054683, 48.69005384564221, nil),
//		*NewPoint(-5.080490112304683, 48.803471664383096, nil),
//		*NewPoint(-4.904708862304683, 47.97912122349871, nil),
//		*NewPoint(-2.723236083984373, 47.16450869129574, nil),
//		*NewPoint(-1.6956710815429656, 46.10775536585561, nil),
//		*NewPoint(-1.722450256347653, 44.31844432059691, nil),
//		*NewPoint(-1.6991043090820295, 43.32317958748908, nil),
//	}}
//	t.Log(vectorCalc.areaOfPolygon(polygon) * EarthRadius2)
//}
//func TestVectorCalculator_Triangle_Area(t *testing.T) {
//	tris := []*Triangle{
//		NewTriangle(
//			NewPoint(0, 0, GeoCtx),
//			NewPoint(90, 0, GeoCtx),
//			NewPoint(0, 90, GeoCtx),
//			GeoCtx,
//		),
//		NewTriangle(
//			NewPoint(0, 0, GeoCtx),
//			NewPoint(90, 0, GeoCtx),
//			NewPoint(45, 45, GeoCtx),
//			GeoCtx,
//		),
//		NewTriangle(
//			NewPoint(0, 0, GeoCtx),
//			NewPoint(30, 30, GeoCtx),
//			NewPoint(45, 45, GeoCtx),
//			GeoCtx,
//		),
//		NewTriangle(
//			NewPoint(90, 0, GeoCtx),
//			NewPoint(-80, 0, GeoCtx),
//			NewPoint(40, 40, GeoCtx),
//			GeoCtx,
//		),
//		NewTriangle(
//			NewPoint(0, 90, GeoCtx),
//			NewPoint(0, -90, GeoCtx),
//			NewPoint(1, 0, GeoCtx),
//			GeoCtx,
//		),
//	}
//	for _, tri := range tris {
//		info.Println(vectorCalc.Area(tri) * EarthRadius2)
//	}
//}
